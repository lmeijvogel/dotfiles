# #!/usr/bin/env ruby
snippet #!
#!/usr/bin/env ruby

# New Block
endsnippet

snippet n
puts "\n"*30
endsnippet

snippet \n
puts "\n"*30
endsnippet

snippet =b
=begin rdoc
  ${1}
=end
endsnippet

snippet y
:yields: ${1:arguments}
endsnippet

snippet rb
#!/usr/bin/env ruby -wKU
endsnippet

snippet beg
begin
  ${3}
rescue ${1:Exception} => ${2:e}
end

endsnippet

snippet req
require "${1}"${2}
endsnippet

snippet #
# =>
endsnippet

snippet end
__END__
endsnippet

snippet case
case ${1:object}
when ${2:condition}
  ${3}
end
endsnippet

snippet when
when ${1:condition}
  ${2}
endsnippet

snippet def
def ${1:method_name}
  ${2}
end
endsnippet

snippet if
if ${1:condition}
  ${2}
end
endsnippet

snippet ife
if ${1:condition}
  ${2}
else
  ${3}
end
endsnippet

snippet elsif
elsif ${1:condition}
  ${2}
endsnippet

snippet unless
unless ${1:condition}
  ${2}
end
endsnippet

snippet while
while ${1:condition}
  ${2}
end
endsnippet

snippet for
for ${1:e} in ${2:c}
  ${3}
end		
endsnippet

snippet until
until ${1:condition}
  ${2}
end
endsnippet

snippet r
attr_reader :${1:attr_names}
# attr_writer
endsnippet

snippet w
attr_writer :${1:attr_names}
# attr_accessor
endsnippet

snippet rw
attr_accessor :${1:attr_names}
# include Enumerable
endsnippet

snippet defs
def self.${1:class_method_name}
  ${2}
end
# def method_missing
endsnippet

snippet am
alias_method :${1:new_name}, :${2:old_name}
endsnippet

snippet ea
each { |${1:e}| ${2} }
endsnippet

snippet ead
each do |${1:e}|
  ${2}
end	
endsnippet

snippet eai
each_index { |${1:i}| ${2} }
endsnippet

snippet eaid
each_index do |${1:i}|
end
endsnippet

snippet eal
each_line { |${1:line}| ${2} }
endsnippet

snippet eald
each_line do |${1:line}|
  ${2}
end		
endsnippet

snippet eap
each_pair { |${1:name}, ${2:val}| ${3} }
endsnippet

snippet eapd
each_pair do |${1:name}, ${2:val}|
  ${3}
end			
endsnippet

snippet eas-
each_slice(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet easd-
each_slice(${1:2}) do |${2:group}|
  ${3}
end		
endsnippet

snippet eav
each_value { |${1:val}| ${2} }
endsnippet

snippet eavd
each_value do |${1:val}| 
  ${2}
end
endsnippet

snippet eawi
each_with_index { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet eawid
each_with_index do |${1:e},${2:i}|
  ${3}
end
endsnippet

snippet reve
reverse_each { |${1:e}| ${2} }
endsnippet

snippet reved
reverse_each do |${1:e}|
  ${2}
end	
endsnippet

snippet inj
inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
endsnippet

snippet injd
inject(${1:init}) do |${2:mem}, ${3:var}|
  ${4}
end		
endsnippet

snippet map
map { |${1:e}| ${2} }
endsnippet

snippet mapd
map do |${1:e}| 
  ${2}
end		
endsnippet

snippet mapwi-
enum_with_index.map { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet sor
sort { |a, b| ${1} }
endsnippet

snippet sorb
sort_by { |${1:e}| ${2} }
endsnippet

snippet ran
sort_by { rand }
endsnippet

snippet all
all? { |${1:e}| ${2} }
endsnippet

snippet any
any? { |${1:e}| ${2} }
endsnippet

snippet cl
classify { |${1:e}| ${2} }
endsnippet

snippet col
collect { |${1:e}| ${2} }
endsnippet

snippet cold
collect do |${1:e}|
  ${2}
end
endsnippet

snippet det
detect { |${1:e}| ${2} }
endsnippet

snippet detd
detect do |${1:e}|
  ${2}
end
endsnippet

snippet fet
fetch(${1:name}) { |${2:key}| ${3} }
endsnippet

snippet fin
find { |${1:e}| ${2} }
endsnippet

snippet find
find do |${1:e}|
  ${2}
end		
endsnippet

snippet fina
find_all { |${1:e}| ${2} }
endsnippet

snippet finad
find_all do |${1:e}|
  ${2}
end			
endsnippet

snippet gre
grep(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet sub
${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
endsnippet

snippet sca
scan(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet scad
scan(${1:/pattern/}) do |${2:match}|
  ${3}
end		
endsnippet

snippet max
max { |a, b| ${1} }
endsnippet

snippet min
min { |a, b| ${1} }
endsnippet

snippet par
partition { |${1:e}| ${2} }
endsnippet

snippet pard
partition do |${1:e}|
  ${2}
end		
endsnippet

snippet rej
reject { |${1:e}| ${2} }
endsnippet

snippet rejd
reject do |${1:e}|
  ${2}
end
endsnippet

snippet sel
select { |${1:e}| ${2} }
endsnippet

snippet seld
select do |${1:e}|
  ${2}
end		
endsnippet

snippet lam
lambda { |${1:args}| ${2} }
endsnippet

snippet do
do |${1:variable}|
  ${2}
end
endsnippet

snippet :
:${1:key} => ${2:"value"}${3}
endsnippet

snippet ope
open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# path_from_here()
endsnippet

snippet patfh
File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}
# unix_filter {}
endsnippet

snippet unif
ARGF.each_line${1} do |${2:line}|
  ${3}
end
# option_parse {}
endsnippet

snippet optp
require "optparse"

options = {${1:default => "args"}}

ARGV.options do |opts|
  opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
endsnippet

snippet opt
opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
         "${4:Option description.}") do |${5:opt}|
  ${6}
end
endsnippet

snippet bm-
TESTS = ${1:10_000}
Benchmark.bmbm do |results|
  ${2}
end
endsnippet

snippet rep
results.report("${1:name}:") { TESTS.times { ${2} }}
# Marshal.dump(.., file)
endsnippet

snippet Md
File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
endsnippet

snippet Ml
File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }${3}
# deep_copy(..)
endsnippet

snippet deec
Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
endsnippet

snippet Pn-
PStore.new(${1:"file_name.pstore"})${2}
endsnippet

snippet tra
transaction(${1:true}) { ${2} }
# xmlread(..)
endsnippet

snippet xml-
REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..) { .. }
endsnippet

snippet xpa
elements.each(${1:"//Xpath"}) do |${2:node}|
  ${3}
end
# class_from_name()
endsnippet

snippet clafn
split("::").inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
endsnippet

snippet sinc
class << self; self end
endsnippet

snippet nam
namespace :${1:`Filename()`} do
  ${2}
end
endsnippet

snippet tas
desc "${1:Task description\}"
task :${2:task_name => [:dependent, :tasks]} do
  ${3}
end

# My own snippets
endsnippet

snippet spec
require "spec_helper"

describe ${1:class_under_spec} do
  # Test basic functionality - Delete after first run
  it "fails" do
    expect(true).to eq false
  end

  it "succeeds" do
    expect(true).to eq true
  end
end
endsnippet

snippet cspec
require "spec_helper"

describe ${1:class_under_spec} do
  include ControllerSpecHelper

  # Test basic functionality - Delete after first run
  it "should fail" do
    true.should == false
  end

  it "should succeed" do
    true.should == true
  end
end
endsnippet

snippet be
before do
  ${1}
end
endsnippet

snippet cx
context "when ${1}" do
  ${2}
end
endsnippet

snippet ds
describe ${1} do
  ${2}
end
endsnippet

snippet it
it "should ${1}" do
  ${2}
end
endsnippet

snippet rli
Rails.logger.info "${1}"

endsnippet

snippet rle
Rails.logger.error "${1}"
endsnippet

snippet byebug
require 'byebug' ; byebug
endsnippet

snippet bug
require 'byebug' ; byebug
endsnippet

snippet shot
save_screenshot('/tmp/screenshot$1.png', full: true)
endsnippet

snippet html
save_page('/tmp/page.html')
endsnippet
